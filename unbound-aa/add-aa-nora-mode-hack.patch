diff --git a/util/data/msgencode.c b/util/data/msgencode.c
index 5f297b5..b34773c 100644
--- a/util/data/msgencode.c
+++ b/util/data/msgencode.c
@@ -874,6 +874,8 @@ attach_edns_record(sldns_buffer* pkt, struct edns_data* edns)
 	attach_edns_record_max_msg_sz(pkt, edns, edns->udp_size);
 }
 
+static int send_aa_nora_replies = 0;
+
 int
 reply_info_answer_encode(struct query_info* qinf, struct reply_info* rep,
 	uint16_t id, uint16_t qflags, sldns_buffer* pkt, time_t timenow,
@@ -883,13 +885,20 @@ reply_info_answer_encode(struct query_info* qinf, struct reply_info* rep,
 	uint16_t flags;
 	unsigned int attach_edns = 0;
 
-	if(!cached || rep->authoritative) {
+	if(!send_aa_nora_replies)
+		send_aa_nora_replies = getenv("UNBOUND_AA_NORA_MODE") ? 1 : 2;
+
+	if(send_aa_nora_replies == 1) {
+		flags = rep->flags | (qflags & (BIT_RD|BIT_CD));
+		flags |= BIT_AA; flags &= ~BIT_RA;
+	} else if(!cached || rep->authoritative) {
 		/* original flags, copy RD and CD bits from query. */
 		flags = rep->flags | (qflags & (BIT_RD|BIT_CD));
 	} else {
 		/* remove AA bit, copy RD and CD bits from query. */
 		flags = (rep->flags & ~BIT_AA) | (qflags & (BIT_RD|BIT_CD));
 	}
+
 	if(secure && (dnssec || (qflags&BIT_AD)))
 		flags |= BIT_AD;
 	/* restore AA bit if we have a local alias and the response can be
